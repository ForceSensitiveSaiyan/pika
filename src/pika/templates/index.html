{% extends "base.html" %}

{% block title %}PIKA - Chat{% endblock %}

{% block content %}
<!-- Header -->
<header class="header">
    <div class="header-left">
        <a href="/" class="logo">PIKA</a>
        <span class="status-dot" id="status-indicator" title="System status"></span>
    </div>
    <div class="header-right">
        <button class="btn btn-ghost header-link" id="history-toggle" onclick="toggleHistory()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
            History
        </button>
        <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
            <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
        {% if is_admin %}
        <a href="/admin" class="header-link">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
            Admin
        </a>
        {% endif %}
        {% if user %}
        <a href="/admin/logout" class="header-link">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                <polyline points="16 17 21 12 16 7"></polyline>
                <line x1="21" y1="12" x2="9" y2="12"></line>
            </svg>
            Logout
        </a>
        {% endif %}
    </div>
</header>

<!-- History Panel -->
<div class="history-panel hidden" id="history-panel">
    <div class="history-header">
        <h3 class="history-title">Recent Queries</h3>
        <div class="history-header-actions">
            <button class="btn btn-ghost btn-icon" onclick="clearChatHistory()" title="Clear history">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="3 6 5 6 21 6"></polyline>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
            </button>
            <button class="btn btn-ghost btn-icon" onclick="toggleHistory()" title="Close">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
    </div>
    <div class="history-list" id="history-list">
        <div class="history-empty">No recent queries</div>
    </div>
</div>

{% if is_admin %}
<div class="onboarding-banner hidden" id="onboarding-banner">
    <div class="onboarding-banner-content">
        <span class="onboarding-banner-eyebrow">Get started</span>
        <h2 class="onboarding-banner-title" id="onboarding-title">Add documents to start chatting</h2>
        <p class="onboarding-banner-text" id="onboarding-text">
            Upload files in Admin, then refresh the index to enable answers.
        </p>
    </div>
    <div class="onboarding-banner-actions">
        <button class="btn btn-secondary hidden" id="onboarding-refresh" type="button">Refresh Index</button>
        <a class="btn btn-primary" href="/admin">Open Admin</a>
    </div>
</div>
{% endif %}

<!-- Chat Layout -->
<div class="chat-layout">
    <div class="chat-messages" id="chat-messages">
        <div class="welcome" id="welcome">
            <svg class="welcome-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
            <h1 class="welcome-title">Ask anything about your documents</h1>
            <p class="welcome-text">
                {% if is_admin %}
                Upload and index documents in the <a href="/admin">Admin</a> section, then ask questions here.
                {% else %}
                Ask questions about the documents that have been indexed.
                {% endif %}
            </p>
        </div>
    </div>

    <div class="chat-input-container">
        <form class="chat-input-wrapper" id="chat-form" onsubmit="sendQuestion(event)">
            <input
                type="text"
                class="chat-input"
                id="question-input"
                placeholder="Ask a question..."
                autocomplete="off"
            >
            <button type="submit" class="btn btn-primary chat-send-btn" id="send-btn">
                Send
            </button>
            <button type="button" class="btn btn-danger chat-send-btn hidden" id="stop-btn" onclick="cancelQuery()">
                Stop
            </button>
        </form>
    </div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toast-container"></div>
{% endblock %}

{% block scripts %}
<script>
    const IS_ADMIN = {{ 'true' if is_admin else 'false' }};
    const CURRENT_USER = '{{ user.username if user else '' }}';

    // Theme toggle
    function toggleTheme() {
        const html = document.documentElement;
        const current = html.getAttribute('data-theme');
        const next = current === 'dark' ? 'light' : 'dark';
        html.setAttribute('data-theme', next);
        localStorage.setItem('pika_theme', next);
    }

    let isLoading = false;
    let messageCounter = 0;
    let chatHistory = []; // {type, content, result?, queryId?}
    let queryPollingInterval = null;
    let currentLoadingId = null;
    let currentQueryId = null;
    let historyVisible = false;

    // Get user-specific storage key
    function getChatHistoryKey() {
        return CURRENT_USER ? `pika_chat_history_${CURRENT_USER}` : 'pika_chat_history';
    }

    // Status indicator polling
    let statusPollInterval = null;

    async function updateStatusIndicator() {
        const dot = document.getElementById('status-indicator');

        try {
            const response = await fetch('/api/v1/status/quick');
            if (!response.ok) throw new Error('Status check failed');

            const status = await response.json();

            // Remove all status classes
            dot.classList.remove('status-ready', 'status-indexing', 'status-limited', 'status-offline');

            if (status.status === 'healthy') {
                if (status.indexing_in_progress) {
                    dot.classList.add('status-indexing');
                    dot.title = 'Indexing in background';
                } else {
                    dot.classList.add('status-ready');
                    dot.title = 'Ready';
                }
            } else if (status.status === 'degraded') {
                dot.classList.add('status-limited');
                dot.title = status.circuit_breaker_open
                    ? 'Limited Â· AI recovering'
                    : 'Limited functionality';
            } else {
                dot.classList.add('status-offline');
                dot.title = 'Offline';
            }
        } catch (error) {
            console.warn('Failed to fetch status:', error);
            dot.classList.remove('status-ready', 'status-indexing', 'status-limited');
            dot.classList.add('status-offline');
            dot.title = 'Offline';
        }
    }

    function startStatusPolling() {
        // Initial check
        updateStatusIndicator();
        // Poll every 30 seconds
        statusPollInterval = setInterval(updateStatusIndicator, 30000);
    }

    function stopStatusPolling() {
        if (statusPollInterval) {
            clearInterval(statusPollInterval);
            statusPollInterval = null;
        }
    }

    // Restore chat history on page load
    document.addEventListener('DOMContentLoaded', () => {
        restoreChatHistory();
        updateOnboarding();
        checkActiveQuery();
        loadHistory();
        startStatusPolling();
    });

    function saveChatHistory() {
        sessionStorage.setItem(getChatHistoryKey(), JSON.stringify(chatHistory));
    }

    function restoreChatHistory() {
        const saved = sessionStorage.getItem(getChatHistoryKey());
        if (!saved) return;

        try {
            chatHistory = JSON.parse(saved);
            if (chatHistory.length === 0) return;

            // Remove welcome message
            const welcome = document.getElementById('welcome');
            if (welcome) welcome.remove();

            // Restore messages
            for (const msg of chatHistory) {
                if (msg.type === 'user') {
                    addMessage(msg.content, 'user');
                } else if (msg.type === 'assistant' && msg.result) {
                    addAnswerMessage(msg.result, msg.queryId);
                } else if (msg.type === 'error') {
                    addMessage(msg.content, 'error');
                }
            }

            // Scroll to bottom after restoring history
            scrollToBottom();
        } catch (e) {
            console.error('Failed to restore chat history:', e);
            chatHistory = [];
        }
    }

    function scrollToBottom() {
        const container = document.getElementById('chat-messages');
        container.scrollTop = container.scrollHeight;
        // Also scroll the input into view
        document.getElementById('question-input').scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    // ==================== History Panel ====================

    function toggleHistory() {
        const panel = document.getElementById('history-panel');
        historyVisible = !historyVisible;
        if (historyVisible) {
            panel.classList.remove('hidden');
            loadHistory();
        } else {
            panel.classList.add('hidden');
        }
    }

    async function loadHistory() {
        const list = document.getElementById('history-list');
        try {
            const response = await fetch('/api/v1/history?limit=20');
            if (!response.ok) throw new Error('Failed to load history');

            const entries = await response.json();

            if (entries.length === 0) {
                list.innerHTML = '<div class="history-empty">No recent queries</div>';
                return;
            }

            list.innerHTML = entries.map(entry => `
                <div class="history-item" onclick="runHistoryQuery('${escapeHtml(entry.question.replace(/'/g, "\\'"))}')">
                    <div class="history-question">${escapeHtml(entry.question)}</div>
                    <div class="history-meta">
                        <span class="confidence confidence-${entry.confidence}">
                            <span class="confidence-dot"></span>
                            ${entry.confidence}
                        </span>
                        <span class="history-time">${formatTime(entry.timestamp)}</span>
                    </div>
                </div>
            `).join('');
        } catch (error) {
            console.error('Failed to load history:', error);
            list.innerHTML = '<div class="history-empty">Failed to load history</div>';
        }
    }

    function runHistoryQuery(question) {
        const input = document.getElementById('question-input');
        input.value = question;
        toggleHistory();
        document.getElementById('chat-form').dispatchEvent(new Event('submit'));
    }

    async function clearChatHistory() {
        if (!confirm('Clear all chat history? This will remove both the current conversation and saved query history.')) {
            return;
        }

        try {
            // Clear server-side history
            const response = await fetch('/api/v1/history', { method: 'DELETE' });
            if (!response.ok) throw new Error('Failed to clear server history');

            // Clear client-side session storage
            sessionStorage.removeItem(getChatHistoryKey());
            chatHistory = [];

            // Reset chat UI
            const container = document.getElementById('chat-messages');
            container.innerHTML = `
                <div class="welcome" id="welcome">
                    <svg class="welcome-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    <h1 class="welcome-title">Ask anything about your documents</h1>
                    <p class="welcome-text">
                        ${IS_ADMIN
                            ? 'Upload and index documents in the <a href="/admin">Admin</a> section, then ask questions here.'
                            : 'Ask questions about the documents that have been indexed.'}
                    </p>
                </div>
            `;

            // Refresh history panel
            loadHistory();

            // Update onboarding if needed
            await updateOnboarding();

            showToast('Chat history cleared', 'success');
        } catch (error) {
            console.error('Failed to clear history:', error);
            showToast('Failed to clear history', 'error');
        }
    }

    function formatTime(isoString) {
        const date = new Date(isoString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
    }

    function formatWaitTime(seconds) {
        if (seconds < 60) return `${seconds}s`;
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        if (mins < 60) return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
        const hours = Math.floor(mins / 60);
        const remainMins = mins % 60;
        return `${hours}h ${remainMins}m`;
    }

    function updateLoadingMessage(status) {
        if (!currentLoadingId) return;
        const loadingEl = document.getElementById(currentLoadingId);
        if (!loadingEl) return;

        const contentEl = loadingEl.querySelector('.message-content');
        if (!contentEl) return;

        if (status.status === 'queued') {
            const position = status.queue_position || 1;
            const queueLength = status.queue_length || 1;
            const waitTime = status.estimated_wait_seconds;
            let message = `Queued (position ${position} of ${queueLength})`;
            if (waitTime !== null && waitTime !== undefined) {
                message += ` - estimated wait: ${formatWaitTime(waitTime)}`;
            }
            contentEl.textContent = message;
            contentEl.classList.remove('loading-dots');
        } else if (status.status === 'running') {
            contentEl.textContent = 'Thinking';
            contentEl.classList.add('loading-dots');
        }
    }

    // ==================== Query Status ====================

    async function checkActiveQuery() {
        try {
            const response = await fetch('/api/v1/query/status');
            const status = await response.json();

            if (status.status === 'running' || status.status === 'queued') {
                isLoading = true;
                updateSendButton();
                currentQueryId = status.query_id;

                const welcome = document.getElementById('welcome');
                if (welcome) welcome.remove();

                const onboarding = document.getElementById('onboarding-banner');
                if (onboarding) onboarding.classList.add('hidden');

                const lastMsg = chatHistory[chatHistory.length - 1];
                if (!lastMsg || lastMsg.type !== 'user' || lastMsg.content !== status.question) {
                    addMessage(status.question, 'user');
                    chatHistory.push({ type: 'user', content: status.question });
                    saveChatHistory();
                }

                // Show appropriate loading message based on status
                const loadingText = status.status === 'queued'
                    ? `Queued (position ${status.queue_position || 1} of ${status.queue_length || 1})`
                    : 'Thinking';
                currentLoadingId = addMessage(loadingText, 'assistant', true);
                if (status.status === 'queued') {
                    updateLoadingMessage(status);
                }
                startQueryPolling();
            } else if (status.status === 'completed' && status.result) {
                const welcome = document.getElementById('welcome');
                if (welcome) welcome.remove();

                const onboarding = document.getElementById('onboarding-banner');
                if (onboarding) onboarding.classList.add('hidden');

                const lastMsg = chatHistory[chatHistory.length - 1];
                if (lastMsg && lastMsg.type === 'user' && lastMsg.content === status.question) {
                    addAnswerMessage(status.result, status.query_id);
                    chatHistory.push({ type: 'assistant', result: status.result, queryId: status.query_id });
                    saveChatHistory();
                }

                await fetch('/api/v1/query/status', { method: 'DELETE' });
            } else if (status.status === 'none') {
                // No active query on backend - check for interrupted streaming query
                const streamingState = getStreamingState();
                if (streamingState) {
                    // Streaming query was interrupted by navigation
                    clearStreamingState();
                    const lastMsg = chatHistory[chatHistory.length - 1];
                    if (lastMsg && lastMsg.type === 'user' && lastMsg.content === streamingState.question) {
                        // Add an info message about the interruption
                        addMessage('Query was interrupted. Please try again.', 'error');
                        chatHistory.push({ type: 'error', content: 'Query was interrupted. Please try again.' });
                        saveChatHistory();
                    }
                } else {
                    // Check if frontend thinks one is running (stale state from container restart)
                    const lastMsg = chatHistory[chatHistory.length - 1];
                    if (lastMsg && lastMsg.type === 'user') {
                        // Last message was a user question with no answer - might be stale
                        const loadingMsgs = document.querySelectorAll('.message-loading');
                        if (loadingMsgs.length > 0) {
                            loadingMsgs.forEach(el => el.remove());
                            showToast('Previous query was interrupted', 'info');
                        }
                    }
                }
                // Reset loading state just in case
                isLoading = false;
                updateSendButton();
            }
        } catch (error) {
            console.error('Failed to check query status:', error);
            // On error, reset to safe state
            isLoading = false;
            updateSendButton();
        }
    }

    function startQueryPolling() {
        if (queryPollingInterval) return;

        queryPollingInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/v1/query/status');
                const status = await response.json();

                if (status.status === 'completed') {
                    stopQueryPolling();

                    // Use currentLoadingId as guard - only first callback to arrive processes completion
                    // This prevents duplicate messages from concurrent async callbacks
                    if (currentLoadingId) {
                        removeMessage(currentLoadingId);
                        currentLoadingId = null;

                        if (status.result) {
                            addAnswerMessage(status.result, status.query_id);
                            chatHistory.push({ type: 'assistant', result: status.result, queryId: status.query_id });
                            saveChatHistory();
                        }

                        isLoading = false;
                        updateSendButton();
                        await updateOnboarding();
                        await fetch('/api/v1/query/status', { method: 'DELETE' });
                    }

                } else if (status.status === 'error' || status.status === 'cancelled') {
                    stopQueryPolling();

                    // Use currentLoadingId as guard for error/cancel handling too
                    if (currentLoadingId) {
                        removeMessage(currentLoadingId);
                        currentLoadingId = null;

                        const errorMsg = status.status === 'cancelled'
                            ? 'Query was cancelled'
                            : 'Error: ' + (status.error || 'Query failed');
                        addMessage(errorMsg, 'error');
                        chatHistory.push({ type: 'error', content: errorMsg });
                        saveChatHistory();

                        isLoading = false;
                        updateSendButton();
                        await fetch('/api/v1/query/status', { method: 'DELETE' });
                    }

                } else if (status.status === 'queued' || status.status === 'running') {
                    // Update loading message with queue position or running status
                    updateLoadingMessage(status);

                } else if (status.status === 'none' && isLoading) {
                    // Stale query detection: backend has no query but frontend thinks one is running
                    // This can happen after container restart
                    console.warn('Stale query detected - resetting UI state');
                    stopQueryPolling();

                    if (currentLoadingId) {
                        removeMessage(currentLoadingId);
                        currentLoadingId = null;
                    }

                    // Don't add error message, just reset silently or show info
                    showToast('Query state was reset', 'info');

                    isLoading = false;
                    updateSendButton();
                }
            } catch (error) {
                console.error('Failed to poll query status:', error);
            }
        }, 500);
    }

    function stopQueryPolling() {
        if (queryPollingInterval) {
            clearInterval(queryPollingInterval);
            queryPollingInterval = null;
        }
    }

    // ==================== Onboarding ====================

    async function updateOnboarding() {
        const banner = document.getElementById('onboarding-banner');
        const title = document.getElementById('onboarding-title');
        const text = document.getElementById('onboarding-text');
        const refreshButton = document.getElementById('onboarding-refresh');

        try {
            const [documentsResponse, statsResponse, statusResponse] = await Promise.all([
                fetch('/documents'),
                fetch('/api/v1/index/stats'),
                fetch('/api/v1/status/quick')
            ]);

            if (!documentsResponse.ok || !statsResponse.ok) {
                banner.classList.add('hidden');
                return;
            }

            const documents = await documentsResponse.json();
            const stats = await statsResponse.json();
            const status = statusResponse.ok ? await statusResponse.json() : { indexing_in_progress: false };

            // Hide banner during indexing - the status dot already indicates progress
            if (status.indexing_in_progress) {
                banner.classList.add('hidden');
                return;
            }

            if (!documents.length) {
                title.textContent = 'Add documents to start chatting';
                text.textContent = 'Upload files in Admin, then refresh the index to enable answers.';
                refreshButton.classList.add('hidden');
                banner.classList.remove('hidden');
                return;
            }

            if (stats.total_chunks === 0) {
                title.textContent = 'Index your documents';
                text.textContent = 'Your files are uploaded. Refresh the index so PIKA can answer questions.';
                refreshButton.classList.remove('hidden');
                banner.classList.remove('hidden');
                return;
            }

            banner.classList.add('hidden');
        } catch (error) {
            console.error('Failed to update onboarding banner:', error);
            banner.classList.add('hidden');
        }
    }

    async function refreshIndexFromBanner() {
        const refreshButton = document.getElementById('onboarding-refresh');
        refreshButton.disabled = true;
        refreshButton.innerHTML = '<span class="spinner"></span>';

        try {
            const response = await fetch('/api/v1/index', { method: 'POST' });
            if (!response.ok) throw new Error('Failed to refresh index');
            showToast('Index refreshed', 'success');
            await updateOnboarding();
        } catch (error) {
            showToast('Failed to refresh index', 'error');
        } finally {
            refreshButton.disabled = false;
            refreshButton.textContent = 'Refresh Index';
        }
    }

    // ==================== Send Question ====================

    // Streaming message state
    let streamingMsgId = null;
    let streamingContent = '';
    let streamingSources = [];
    let streamingConfidence = null;
    let hasStartedStreaming = false;
    let streamingAbortController = null;

    // Track streaming state for navigation recovery
    function getStreamingStateKey() {
        return CURRENT_USER ? `pika_streaming_${CURRENT_USER}` : 'pika_streaming';
    }

    function saveStreamingState(question) {
        sessionStorage.setItem(getStreamingStateKey(), JSON.stringify({
            question: question,
            timestamp: Date.now()
        }));
    }

    function clearStreamingState() {
        sessionStorage.removeItem(getStreamingStateKey());
    }

    function getStreamingState() {
        const saved = sessionStorage.getItem(getStreamingStateKey());
        if (!saved) return null;
        try {
            const state = JSON.parse(saved);
            // Only recover if interrupted within last 5 minutes
            if (Date.now() - state.timestamp > 300000) {
                clearStreamingState();
                return null;
            }
            return state;
        } catch (e) {
            return null;
        }
    }

    function convertLoadingToStreaming(loadingMsgId) {
        // Convert the "Thinking..." loading message to a streaming message
        const msg = document.getElementById(loadingMsgId);
        if (!msg) return loadingMsgId;

        msg.classList.remove('message-loading');
        msg.classList.add('message-streaming');

        const bubble = msg.querySelector('.message-bubble');
        if (bubble) {
            bubble.innerHTML = `
                <div class="message-content streaming-content"></div>
                <div class="streaming-cursor"></div>
            `;
        }

        return loadingMsgId;
    }

    function updateStreamingMessage(msgId, content) {
        const msg = document.getElementById(msgId);
        if (!msg) return;

        const contentEl = msg.querySelector('.streaming-content');
        if (contentEl) {
            contentEl.textContent = content;
        }

        // Auto-scroll
        const container = document.getElementById('chat-messages');
        container.scrollTop = container.scrollHeight;
    }

    function finalizeStreamingMessage(msgId, result, queryId) {
        const msg = document.getElementById(msgId);
        if (!msg) return;

        msg.classList.remove('message-streaming');
        msg.classList.remove('message-loading');

        // Remove cursor if present
        const cursor = msg.querySelector('.streaming-cursor');
        if (cursor) cursor.remove();

        // Build full message HTML (same structure as addAnswerMessage)
        let sourcesHtml = '';
        if (result.sources && result.sources.length > 0) {
            const uniqueSources = [...new Set(result.sources.map(s => s.filename))];
            sourcesHtml = `
                <div class="message-sources">
                    <span class="source-label">Sources</span>
                    ${uniqueSources.map(f => `<span class="source-pill">${escapeHtml(f)}</span>`).join('')}
                </div>
            `;
        }

        const isNoResults = result.confidence === 'none';
        let noResultsHint = '';
        if (isNoResults && IS_ADMIN) {
            noResultsHint = `
                <div class="no-results-hint">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    Try adding more documents in the <a href="/admin">Admin</a> panel
                </div>
            `;
        } else if (isNoResults) {
            noResultsHint = `
                <div class="no-results-hint">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    No relevant information found in the indexed documents.
                </div>
            `;
        }

        // Get the last user question for feedback
        const safeQuestion = chatHistory.filter(m => m.type === 'user').pop()?.content || '';

        const bubble = msg.querySelector('.message-bubble');
        bubble.innerHTML = `
            <div class="message-content">${escapeHtml(result.answer)}</div>
            ${sourcesHtml}
            ${noResultsHint}
            <div class="message-footer">
                <span class="confidence confidence-${result.confidence}">
                    <span class="confidence-dot"></span>
                    ${result.confidence}
                </span>
                <div class="message-actions">
                    <button class="action-btn" onclick="copyAnswer(this, '${msgId}')" title="Copy answer">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                    <button class="action-btn feedback-btn" onclick="submitFeedback('${queryId || ''}', 'up', this)" title="Helpful" data-rating="">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                        </svg>
                    </button>
                    <button class="action-btn feedback-btn" onclick="submitFeedback('${queryId || ''}', 'down', this)" title="Not helpful" data-rating="">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
                        </svg>
                    </button>
                </div>
            </div>
        `;

        // Store answer text for copy and feedback (same as addAnswerMessage)
        msg.dataset.answer = result.answer;
        msg.dataset.question = safeQuestion;
    }

    async function sendQuestionStreaming(question, loadingMsgId) {
        // Start with the existing loading message showing "Thinking..."
        streamingMsgId = loadingMsgId;
        streamingContent = '';
        streamingSources = [];
        streamingConfidence = null;
        hasStartedStreaming = false;

        // Track streaming state for navigation recovery
        saveStreamingState(question);

        // Use AbortController for clean cancellation
        streamingAbortController = new AbortController();

        try {
            const response = await fetch('/api/v1/query/stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question }),
                signal: streamingAbortController.signal
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Query failed');
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });

                // Parse SSE events from buffer - split on double newline for complete events
                let eventEnd;
                while ((eventEnd = buffer.indexOf('\n\n')) !== -1) {
                    const eventBlock = buffer.slice(0, eventEnd);
                    buffer = buffer.slice(eventEnd + 2);

                    // Parse the event block
                    let eventType = 'message';
                    let eventData = null;

                    for (const line of eventBlock.split('\n')) {
                        if (line.startsWith('event: ')) {
                            eventType = line.slice(7).trim();
                        } else if (line.startsWith('data: ')) {
                            try {
                                eventData = JSON.parse(line.slice(6));
                            } catch (e) {
                                console.warn('Failed to parse SSE data:', line);
                            }
                        }
                    }

                    if (!eventData) continue;

                    if (eventData.type === 'metadata') {
                        streamingSources = eventData.sources || [];
                        streamingConfidence = eventData.confidence;
                    } else if (eventData.type === 'token') {
                        // First token - convert loading message to streaming
                        if (!hasStartedStreaming) {
                            hasStartedStreaming = true;
                            convertLoadingToStreaming(streamingMsgId);
                        }
                        streamingContent += eventData.content;
                        updateStreamingMessage(streamingMsgId, streamingContent);
                    } else if (eventData.type === 'done') {
                        // Finalize the message - clear streaming state first
                        clearStreamingState();
                        streamingAbortController = null;

                        const result = {
                            answer: eventData.answer || streamingContent,
                            sources: streamingSources,
                            confidence: streamingConfidence || 'medium'
                        };
                        const queryId = 'stream-' + Date.now();
                        finalizeStreamingMessage(streamingMsgId, result, queryId);
                        chatHistory.push({ type: 'assistant', result, queryId });
                        saveChatHistory();
                        return true;
                    } else if (eventData.type === 'error') {
                        throw new Error(eventData.message || 'Query failed');
                    }
                }
            }

            // If we get here without a 'done' event, finalize with what we have
            clearStreamingState();
            streamingAbortController = null;

            if (streamingContent) {
                const result = {
                    answer: streamingContent,
                    sources: streamingSources,
                    confidence: streamingConfidence || 'medium'
                };
                const queryId = 'stream-' + Date.now();
                finalizeStreamingMessage(streamingMsgId, result, queryId);
                chatHistory.push({ type: 'assistant', result, queryId });
                saveChatHistory();
            }

            return true;

        } catch (error) {
            streamingAbortController = null;

            // Don't clear streaming state on abort - leave it for navigation recovery
            if (error.name !== 'AbortError') {
                clearStreamingState();
            }

            // Remove streaming message on error
            if (streamingMsgId) {
                removeMessage(streamingMsgId);
                streamingMsgId = null;
            }
            throw error;
        }
    }

    async function sendQuestion(event) {
        event.preventDefault();

        const input = document.getElementById('question-input');
        const question = input.value.trim();

        if (!question || isLoading) return;

        input.value = '';
        isLoading = true;
        updateSendButton();

        const welcome = document.getElementById('welcome');
        if (welcome) welcome.remove();

        const onboarding = document.getElementById('onboarding-banner');
        if (onboarding) onboarding.classList.add('hidden');

        addMessage(question, 'user');
        chatHistory.push({ type: 'user', content: question });
        saveChatHistory();

        // Show "Thinking..." loading message
        currentLoadingId = addMessage('Thinking', 'assistant', true);

        // Use polling-based queries (tracks state on server, survives navigation)
        try {
            const response = await fetch('/api/v1/query', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question })
            });

            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.detail || 'Query failed');
            }

            currentQueryId = result.query_id;

            // Update loading message if queued
            if (result.status === 'queued') {
                updateLoadingMessage(result);
            }

            startQueryPolling();

        } catch (error) {
            if (currentLoadingId) {
                removeMessage(currentLoadingId);
                currentLoadingId = null;
            }
            addMessage('Error: ' + error.message, 'error');
            chatHistory.push({ type: 'error', content: 'Error: ' + error.message });
            saveChatHistory();
            isLoading = false;
            updateSendButton();
        }
    }

    // ==================== Messages ====================

    function addMessage(content, type, isLoading = false) {
        const container = document.getElementById('chat-messages');
        const id = 'msg-' + (messageCounter++);

        const div = document.createElement('div');
        div.id = id;
        div.className = `message message-${type}${isLoading ? ' message-loading' : ''}`;

        const loadingClass = isLoading ? ' loading-dots' : '';
        div.innerHTML = `
            <div class="message-bubble">
                <div class="message-content${loadingClass}">${escapeHtml(content)}</div>
            </div>
        `;

        container.appendChild(div);
        container.scrollTop = container.scrollHeight;

        return id;
    }

    function addAnswerMessage(result, queryId) {
        const container = document.getElementById('chat-messages');
        const msgId = 'msg-' + (messageCounter++);

        const div = document.createElement('div');
        div.id = msgId;
        div.className = 'message message-assistant';

        let sourcesHtml = '';
        if (result.sources && result.sources.length > 0) {
            const uniqueSources = [...new Set(result.sources.map(s => s.filename))];
            sourcesHtml = `
                <div class="message-sources">
                    <span class="source-label">Sources</span>
                    ${uniqueSources.map(f => `<span class="source-pill">${escapeHtml(f)}</span>`).join('')}
                </div>
            `;
        }

        // Check if this is a "no results" response
        const isNoResults = result.confidence === 'none';
        let noResultsHint = '';
        if (isNoResults && IS_ADMIN) {
            noResultsHint = `
                <div class="no-results-hint">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    Try checking if your documents are indexed in <a href="/admin">Admin</a>
                </div>
            `;
        } else if (isNoResults) {
            noResultsHint = `
                <div class="no-results-hint">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    No relevant information found in the indexed documents.
                </div>
            `;
        }

        const safeAnswer = escapeHtml(result.answer);
        const safeQuestion = chatHistory.filter(m => m.type === 'user').pop()?.content || '';

        div.innerHTML = `
            <div class="message-bubble">
                <div class="message-content">${safeAnswer}</div>
                ${sourcesHtml}
                ${noResultsHint}
                <div class="message-footer">
                    <span class="confidence confidence-${result.confidence}">
                        <span class="confidence-dot"></span>
                        ${result.confidence}
                    </span>
                    <div class="message-actions">
                        <button class="action-btn" onclick="copyAnswer(this, '${msgId}')" title="Copy answer">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                        <button class="action-btn feedback-btn" onclick="submitFeedback('${queryId || ''}', 'up', this)" title="Helpful" data-rating="">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                            </svg>
                        </button>
                        <button class="action-btn feedback-btn" onclick="submitFeedback('${queryId || ''}', 'down', this)" title="Not helpful" data-rating="">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        `;

        // Store answer text for copy
        div.dataset.answer = result.answer;
        div.dataset.question = safeQuestion;

        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

    function removeMessage(id) {
        const el = document.getElementById(id);
        if (el) el.remove();
    }

    // ==================== Actions ====================

    async function copyAnswer(btn, msgId) {
        const msgEl = document.getElementById(msgId);
        if (!msgEl) return;

        const answer = msgEl.dataset.answer;
        if (!answer) return;

        try {
            await navigator.clipboard.writeText(answer);
            btn.classList.add('action-btn-success');
            setTimeout(() => btn.classList.remove('action-btn-success'), 1500);
        } catch (error) {
            console.error('Failed to copy:', error);
            showToast('Failed to copy', 'error');
        }
    }

    async function submitFeedback(queryId, rating, btn) {
        const msgEl = btn.closest('.message');
        if (!msgEl) return;

        const question = msgEl.dataset.question || '';
        const answer = msgEl.dataset.answer || '';

        // Find sibling feedback buttons and update their state
        const footer = btn.closest('.message-actions');
        const feedbackBtns = footer.querySelectorAll('.feedback-btn');

        feedbackBtns.forEach(b => {
            b.classList.remove('action-btn-active');
            b.dataset.rating = '';
        });

        btn.classList.add('action-btn-active');
        btn.dataset.rating = rating;

        try {
            await fetch('/api/v1/feedback', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query_id: queryId,
                    question: question,
                    answer: answer,
                    rating: rating
                })
            });
        } catch (error) {
            console.error('Failed to submit feedback:', error);
        }
    }

    // ==================== Utilities ====================

    function updateSendButton() {
        const sendBtn = document.getElementById('send-btn');
        const stopBtn = document.getElementById('stop-btn');

        if (isLoading) {
            sendBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
        } else {
            sendBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
        }
    }

    async function cancelQuery() {
        const stopBtn = document.getElementById('stop-btn');
        stopBtn.disabled = true;
        stopBtn.innerHTML = '<span class="spinner"></span>';

        // Abort streaming request if in progress
        if (streamingAbortController) {
            streamingAbortController.abort();
            streamingAbortController = null;
            clearStreamingState();
        }

        try {
            const response = await fetch('/api/v1/query/cancel', { method: 'POST' });
            const result = await response.json();

            if (result.cancelled) {
                showToast('Query cancelled', 'info');
            }
        } catch (error) {
            console.error('Failed to cancel query:', error);
        }

        // Reset UI state regardless of cancel result
        stopQueryPolling();
        if (currentLoadingId) {
            removeMessage(currentLoadingId);
            currentLoadingId = null;
        }
        if (streamingMsgId && streamingMsgId !== currentLoadingId) {
            removeMessage(streamingMsgId);
            streamingMsgId = null;
        }
        addMessage('Query cancelled', 'error');
        chatHistory.push({ type: 'error', content: 'Query cancelled' });
        saveChatHistory();

        isLoading = false;
        stopBtn.disabled = false;
        stopBtn.textContent = 'Stop';
        updateSendButton();

        // Clear server-side query status
        await fetch('/api/v1/query/status', { method: 'DELETE' });
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        container.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('hiding');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    document.getElementById('onboarding-refresh').addEventListener('click', () => {
        refreshIndexFromBanner();
    });

    document.getElementById('question-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            document.getElementById('chat-form').dispatchEvent(new Event('submit'));
        }
    });
</script>
{% endblock %}
