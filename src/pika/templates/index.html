{% extends "base.html" %}

{% block title %}PIKA - Chat{% endblock %}

{% block content %}
<!-- Header -->
<header class="header">
    <div class="header-left">
        <a href="/" class="logo">PIKA</a>
    </div>
    <div class="header-right">
        <button class="btn btn-ghost header-link" id="history-toggle" onclick="toggleHistory()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
            History
        </button>
        <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
            <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
        {% if is_admin %}
        <a href="/admin" class="header-link">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
            Admin
        </a>
        {% endif %}
        {% if user %}
        <a href="/admin/logout" class="header-link">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                <polyline points="16 17 21 12 16 7"></polyline>
                <line x1="21" y1="12" x2="9" y2="12"></line>
            </svg>
            Logout
        </a>
        {% endif %}
    </div>
</header>

<!-- History Panel -->
<div class="history-panel hidden" id="history-panel">
    <div class="history-header">
        <h3 class="history-title">Recent Queries</h3>
        <div class="history-header-actions">
            <button class="btn btn-ghost btn-icon" onclick="clearChatHistory()" title="Clear history">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="3 6 5 6 21 6"></polyline>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
            </button>
            <button class="btn btn-ghost btn-icon" onclick="toggleHistory()" title="Close">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
    </div>
    <div class="history-list" id="history-list">
        <div class="history-empty">No recent queries</div>
    </div>
</div>

{% if is_admin %}
<div class="onboarding-banner hidden" id="onboarding-banner">
    <div class="onboarding-banner-content">
        <span class="onboarding-banner-eyebrow">Get started</span>
        <h2 class="onboarding-banner-title" id="onboarding-title">Add documents to start chatting</h2>
        <p class="onboarding-banner-text" id="onboarding-text">
            Upload files in Admin, then refresh the index to enable answers.
        </p>
    </div>
    <div class="onboarding-banner-actions">
        <button class="btn btn-secondary hidden" id="onboarding-refresh" type="button">Refresh Index</button>
        <a class="btn btn-primary" href="/admin">Open Admin</a>
    </div>
</div>
{% endif %}

<!-- Chat Layout -->
<div class="chat-layout">
    <div class="chat-messages" id="chat-messages">
        <div class="welcome" id="welcome">
            <svg class="welcome-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
            <h1 class="welcome-title">Ask anything about your documents</h1>
            <p class="welcome-text">
                {% if is_admin %}
                Upload and index documents in the <a href="/admin">Admin</a> section, then ask questions here.
                {% else %}
                Ask questions about the documents that have been indexed.
                {% endif %}
            </p>
        </div>
    </div>

    <div class="chat-input-container">
        <form class="chat-input-wrapper" id="chat-form" onsubmit="sendQuestion(event)">
            <input
                type="text"
                class="chat-input"
                id="question-input"
                placeholder="Ask a question..."
                autocomplete="off"
            >
            <button type="submit" class="btn btn-primary chat-send-btn" id="send-btn">
                Send
            </button>
            <button type="button" class="btn btn-danger chat-send-btn hidden" id="stop-btn" onclick="cancelQuery()">
                Stop
            </button>
        </form>
    </div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toast-container"></div>
{% endblock %}

{% block scripts %}
<script>
    const IS_ADMIN = {{ 'true' if is_admin else 'false' }};
    const CURRENT_USER = '{{ user.username if user else '' }}';

    // Theme toggle
    function toggleTheme() {
        const html = document.documentElement;
        const current = html.getAttribute('data-theme');
        const next = current === 'dark' ? 'light' : 'dark';
        html.setAttribute('data-theme', next);
        localStorage.setItem('pika_theme', next);
    }

    let isLoading = false;
    let messageCounter = 0;
    let chatHistory = []; // {type, content, result?, queryId?}
    let queryPollingInterval = null;
    let currentLoadingId = null;
    let currentQueryId = null;
    let historyVisible = false;

    // Get user-specific storage key
    function getChatHistoryKey() {
        return CURRENT_USER ? `pika_chat_history_${CURRENT_USER}` : 'pika_chat_history';
    }

    // Restore chat history on page load
    document.addEventListener('DOMContentLoaded', () => {
        restoreChatHistory();
        updateOnboarding();
        checkActiveQuery();
        loadHistory();
    });

    function saveChatHistory() {
        sessionStorage.setItem(getChatHistoryKey(), JSON.stringify(chatHistory));
    }

    function restoreChatHistory() {
        const saved = sessionStorage.getItem(getChatHistoryKey());
        if (!saved) return;

        try {
            chatHistory = JSON.parse(saved);
            if (chatHistory.length === 0) return;

            // Remove welcome message
            const welcome = document.getElementById('welcome');
            if (welcome) welcome.remove();

            // Restore messages
            for (const msg of chatHistory) {
                if (msg.type === 'user') {
                    addMessage(msg.content, 'user');
                } else if (msg.type === 'assistant' && msg.result) {
                    addAnswerMessage(msg.result, msg.queryId);
                } else if (msg.type === 'error') {
                    addMessage(msg.content, 'error');
                }
            }

            // Scroll to bottom after restoring history
            scrollToBottom();
        } catch (e) {
            console.error('Failed to restore chat history:', e);
            chatHistory = [];
        }
    }

    function scrollToBottom() {
        const container = document.getElementById('chat-messages');
        container.scrollTop = container.scrollHeight;
        // Also scroll the input into view
        document.getElementById('question-input').scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    // ==================== History Panel ====================

    function toggleHistory() {
        const panel = document.getElementById('history-panel');
        historyVisible = !historyVisible;
        if (historyVisible) {
            panel.classList.remove('hidden');
            loadHistory();
        } else {
            panel.classList.add('hidden');
        }
    }

    async function loadHistory() {
        const list = document.getElementById('history-list');
        try {
            const response = await fetch('/api/v1/history?limit=20');
            if (!response.ok) throw new Error('Failed to load history');

            const entries = await response.json();

            if (entries.length === 0) {
                list.innerHTML = '<div class="history-empty">No recent queries</div>';
                return;
            }

            list.innerHTML = entries.map(entry => `
                <div class="history-item" onclick="runHistoryQuery('${escapeHtml(entry.question.replace(/'/g, "\\'"))}')">
                    <div class="history-question">${escapeHtml(entry.question)}</div>
                    <div class="history-meta">
                        <span class="confidence confidence-${entry.confidence}">
                            <span class="confidence-dot"></span>
                            ${entry.confidence}
                        </span>
                        <span class="history-time">${formatTime(entry.timestamp)}</span>
                    </div>
                </div>
            `).join('');
        } catch (error) {
            console.error('Failed to load history:', error);
            list.innerHTML = '<div class="history-empty">Failed to load history</div>';
        }
    }

    function runHistoryQuery(question) {
        const input = document.getElementById('question-input');
        input.value = question;
        toggleHistory();
        document.getElementById('chat-form').dispatchEvent(new Event('submit'));
    }

    async function clearChatHistory() {
        if (!confirm('Clear all chat history? This will remove both the current conversation and saved query history.')) {
            return;
        }

        try {
            // Clear server-side history
            const response = await fetch('/api/v1/history', { method: 'DELETE' });
            if (!response.ok) throw new Error('Failed to clear server history');

            // Clear client-side session storage
            sessionStorage.removeItem(getChatHistoryKey());
            chatHistory = [];

            // Reset chat UI
            const container = document.getElementById('chat-messages');
            container.innerHTML = `
                <div class="welcome" id="welcome">
                    <svg class="welcome-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    <h1 class="welcome-title">Ask anything about your documents</h1>
                    <p class="welcome-text">
                        ${IS_ADMIN
                            ? 'Upload and index documents in the <a href="/admin">Admin</a> section, then ask questions here.'
                            : 'Ask questions about the documents that have been indexed.'}
                    </p>
                </div>
            `;

            // Refresh history panel
            loadHistory();

            // Update onboarding if needed
            await updateOnboarding();

            showToast('Chat history cleared', 'success');
        } catch (error) {
            console.error('Failed to clear history:', error);
            showToast('Failed to clear history', 'error');
        }
    }

    function formatTime(isoString) {
        const date = new Date(isoString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
    }

    function formatWaitTime(seconds) {
        if (seconds < 60) return `${seconds}s`;
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        if (mins < 60) return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
        const hours = Math.floor(mins / 60);
        const remainMins = mins % 60;
        return `${hours}h ${remainMins}m`;
    }

    function updateLoadingMessage(status) {
        if (!currentLoadingId) return;
        const loadingEl = document.getElementById(currentLoadingId);
        if (!loadingEl) return;

        const contentEl = loadingEl.querySelector('.message-content');
        if (!contentEl) return;

        if (status.status === 'queued') {
            const position = status.queue_position || 1;
            const queueLength = status.queue_length || 1;
            const waitTime = status.estimated_wait_seconds;
            let message = `Queued (position ${position} of ${queueLength})`;
            if (waitTime !== null && waitTime !== undefined) {
                message += ` - estimated wait: ${formatWaitTime(waitTime)}`;
            }
            contentEl.textContent = message;
            contentEl.classList.remove('loading-dots');
        } else if (status.status === 'running') {
            contentEl.textContent = 'Thinking';
            contentEl.classList.add('loading-dots');
        }
    }

    // ==================== Query Status ====================

    async function checkActiveQuery() {
        try {
            const response = await fetch('/api/v1/query/status');
            const status = await response.json();

            if (status.status === 'running' || status.status === 'queued') {
                isLoading = true;
                updateSendButton();
                currentQueryId = status.query_id;

                const welcome = document.getElementById('welcome');
                if (welcome) welcome.remove();

                const onboarding = document.getElementById('onboarding-banner');
                if (onboarding) onboarding.classList.add('hidden');

                const lastMsg = chatHistory[chatHistory.length - 1];
                if (!lastMsg || lastMsg.type !== 'user' || lastMsg.content !== status.question) {
                    addMessage(status.question, 'user');
                    chatHistory.push({ type: 'user', content: status.question });
                    saveChatHistory();
                }

                // Show appropriate loading message based on status
                const loadingText = status.status === 'queued'
                    ? `Queued (position ${status.queue_position || 1} of ${status.queue_length || 1})`
                    : 'Thinking';
                currentLoadingId = addMessage(loadingText, 'assistant', true);
                if (status.status === 'queued') {
                    updateLoadingMessage(status);
                }
                startQueryPolling();
            } else if (status.status === 'completed' && status.result) {
                const welcome = document.getElementById('welcome');
                if (welcome) welcome.remove();

                const onboarding = document.getElementById('onboarding-banner');
                if (onboarding) onboarding.classList.add('hidden');

                const lastMsg = chatHistory[chatHistory.length - 1];
                if (lastMsg && lastMsg.type === 'user' && lastMsg.content === status.question) {
                    addAnswerMessage(status.result, status.query_id);
                    chatHistory.push({ type: 'assistant', result: status.result, queryId: status.query_id });
                    saveChatHistory();
                }

                await fetch('/api/v1/query/status', { method: 'DELETE' });
            } else if (status.status === 'none') {
                // No active query on backend - check if frontend thinks one is running (stale state)
                // This can happen after container restart while frontend still has cached state
                const lastMsg = chatHistory[chatHistory.length - 1];
                if (lastMsg && lastMsg.type === 'user') {
                    // Last message was a user question with no answer - might be stale
                    // Check if there's a loading message we need to clean up
                    const loadingMsgs = document.querySelectorAll('.message-loading');
                    if (loadingMsgs.length > 0) {
                        loadingMsgs.forEach(el => el.remove());
                        showToast('Previous query was interrupted', 'info');
                    }
                }
                // Reset loading state just in case
                isLoading = false;
                updateSendButton();
            }
        } catch (error) {
            console.error('Failed to check query status:', error);
            // On error, reset to safe state
            isLoading = false;
            updateSendButton();
        }
    }

    function startQueryPolling() {
        if (queryPollingInterval) return;

        queryPollingInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/v1/query/status');
                const status = await response.json();

                if (status.status === 'completed') {
                    stopQueryPolling();

                    // Use currentLoadingId as guard - only first callback to arrive processes completion
                    // This prevents duplicate messages from concurrent async callbacks
                    if (currentLoadingId) {
                        removeMessage(currentLoadingId);
                        currentLoadingId = null;

                        if (status.result) {
                            addAnswerMessage(status.result, status.query_id);
                            chatHistory.push({ type: 'assistant', result: status.result, queryId: status.query_id });
                            saveChatHistory();
                        }

                        isLoading = false;
                        updateSendButton();
                        await updateOnboarding();
                        await fetch('/api/v1/query/status', { method: 'DELETE' });
                    }

                } else if (status.status === 'error' || status.status === 'cancelled') {
                    stopQueryPolling();

                    // Use currentLoadingId as guard for error/cancel handling too
                    if (currentLoadingId) {
                        removeMessage(currentLoadingId);
                        currentLoadingId = null;

                        const errorMsg = status.status === 'cancelled'
                            ? 'Query was cancelled'
                            : 'Error: ' + (status.error || 'Query failed');
                        addMessage(errorMsg, 'error');
                        chatHistory.push({ type: 'error', content: errorMsg });
                        saveChatHistory();

                        isLoading = false;
                        updateSendButton();
                        await fetch('/api/v1/query/status', { method: 'DELETE' });
                    }

                } else if (status.status === 'queued' || status.status === 'running') {
                    // Update loading message with queue position or running status
                    updateLoadingMessage(status);

                } else if (status.status === 'none' && isLoading) {
                    // Stale query detection: backend has no query but frontend thinks one is running
                    // This can happen after container restart
                    console.warn('Stale query detected - resetting UI state');
                    stopQueryPolling();

                    if (currentLoadingId) {
                        removeMessage(currentLoadingId);
                        currentLoadingId = null;
                    }

                    // Don't add error message, just reset silently or show info
                    showToast('Query state was reset', 'info');

                    isLoading = false;
                    updateSendButton();
                }
            } catch (error) {
                console.error('Failed to poll query status:', error);
            }
        }, 500);
    }

    function stopQueryPolling() {
        if (queryPollingInterval) {
            clearInterval(queryPollingInterval);
            queryPollingInterval = null;
        }
    }

    // ==================== Onboarding ====================

    async function updateOnboarding() {
        const banner = document.getElementById('onboarding-banner');
        const title = document.getElementById('onboarding-title');
        const text = document.getElementById('onboarding-text');
        const refreshButton = document.getElementById('onboarding-refresh');

        try {
            const [documentsResponse, statsResponse] = await Promise.all([
                fetch('/documents'),
                fetch('/api/v1/index/stats')
            ]);

            if (!documentsResponse.ok || !statsResponse.ok) {
                banner.classList.add('hidden');
                return;
            }

            const documents = await documentsResponse.json();
            const stats = await statsResponse.json();

            if (!documents.length) {
                title.textContent = 'Add documents to start chatting';
                text.textContent = 'Upload files in Admin, then refresh the index to enable answers.';
                refreshButton.classList.add('hidden');
                banner.classList.remove('hidden');
                return;
            }

            if (stats.total_chunks === 0) {
                title.textContent = 'Index your documents';
                text.textContent = 'Your files are uploaded. Refresh the index so PIKA can answer questions.';
                refreshButton.classList.remove('hidden');
                banner.classList.remove('hidden');
                return;
            }

            banner.classList.add('hidden');
        } catch (error) {
            console.error('Failed to update onboarding banner:', error);
            banner.classList.add('hidden');
        }
    }

    async function refreshIndexFromBanner() {
        const refreshButton = document.getElementById('onboarding-refresh');
        refreshButton.disabled = true;
        refreshButton.innerHTML = '<span class="spinner"></span>';

        try {
            const response = await fetch('/api/v1/index', { method: 'POST' });
            if (!response.ok) throw new Error('Failed to refresh index');
            showToast('Index refreshed', 'success');
            await updateOnboarding();
        } catch (error) {
            showToast('Failed to refresh index', 'error');
        } finally {
            refreshButton.disabled = false;
            refreshButton.textContent = 'Refresh Index';
        }
    }

    // ==================== Send Question ====================

    // Streaming message state
    let streamingMsgId = null;
    let streamingContent = '';
    let streamingSources = [];
    let streamingConfidence = null;

    function createStreamingMessage() {
        const container = document.getElementById('chat-messages');
        const id = 'msg-' + (messageCounter++);

        const div = document.createElement('div');
        div.id = id;
        div.className = 'message message-assistant message-streaming';
        div.innerHTML = `
            <div class="message-bubble">
                <div class="message-content streaming-content"></div>
                <div class="streaming-cursor"></div>
            </div>
        `;

        container.appendChild(div);
        container.scrollTop = container.scrollHeight;

        return id;
    }

    function updateStreamingMessage(msgId, content) {
        const msg = document.getElementById(msgId);
        if (!msg) return;

        const contentEl = msg.querySelector('.streaming-content');
        if (contentEl) {
            // Use innerHTML to support markdown-like formatting
            contentEl.innerHTML = escapeHtml(content);
        }

        // Auto-scroll
        const container = document.getElementById('chat-messages');
        container.scrollTop = container.scrollHeight;
    }

    function finalizeStreamingMessage(msgId, result, queryId) {
        const msg = document.getElementById(msgId);
        if (!msg) return;

        msg.classList.remove('message-streaming');

        // Remove cursor
        const cursor = msg.querySelector('.streaming-cursor');
        if (cursor) cursor.remove();

        // Build full message HTML
        let sourcesHtml = '';
        if (result.sources && result.sources.length > 0) {
            const uniqueSources = [...new Set(result.sources.map(s => s.filename))];
            sourcesHtml = `
                <div class="message-sources">
                    <span class="source-label">Sources</span>
                    ${uniqueSources.map(f => `<span class="source-pill">${escapeHtml(f)}</span>`).join('')}
                </div>
            `;
        }

        const isNoResults = result.confidence === 'none';
        let noResultsHint = '';
        if (isNoResults && IS_ADMIN) {
            noResultsHint = `
                <div class="no-results-hint">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    Try adding more documents in the <a href="/admin">Admin</a> panel
                </div>
            `;
        }

        const bubble = msg.querySelector('.message-bubble');
        bubble.innerHTML = `
            <div class="message-content">${escapeHtml(result.answer)}</div>
            ${sourcesHtml}
            ${noResultsHint}
            <div class="message-confidence confidence-${result.confidence}">
                <span class="confidence-dot"></span>
                ${result.confidence} confidence
            </div>
            <div class="message-feedback" data-query-id="${queryId}">
                <span class="feedback-label">Helpful?</span>
                <button class="feedback-btn" data-rating="up" onclick="submitFeedback('${queryId}', 'up', this)" title="Yes">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                    </svg>
                </button>
                <button class="feedback-btn" data-rating="down" onclick="submitFeedback('${queryId}', 'down', this)" title="No">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
                    </svg>
                </button>
            </div>
        `;
    }

    async function sendQuestionStreaming(question) {
        streamingMsgId = createStreamingMessage();
        streamingContent = '';
        streamingSources = [];
        streamingConfidence = null;

        try {
            const response = await fetch('/api/v1/query/stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Query failed');
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });

                // Parse SSE events from buffer
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // Keep incomplete line in buffer

                let eventType = 'message';
                for (const line of lines) {
                    if (line.startsWith('event: ')) {
                        eventType = line.slice(7).trim();
                    } else if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));

                            if (data.type === 'metadata') {
                                streamingSources = data.sources || [];
                                streamingConfidence = data.confidence;
                            } else if (data.type === 'token') {
                                streamingContent += data.content;
                                updateStreamingMessage(streamingMsgId, streamingContent);
                            } else if (data.type === 'done') {
                                // Finalize the message
                                const result = {
                                    answer: data.answer || streamingContent,
                                    sources: streamingSources,
                                    confidence: streamingConfidence || 'medium'
                                };
                                const queryId = 'stream-' + Date.now();
                                finalizeStreamingMessage(streamingMsgId, result, queryId);
                                chatHistory.push({ type: 'assistant', result, queryId });
                                saveChatHistory();
                                return true;
                            } else if (data.type === 'error') {
                                throw new Error(data.message || 'Query failed');
                            }
                        } catch (parseError) {
                            console.warn('Failed to parse SSE data:', line, parseError);
                        }
                    }
                }
            }

            // If we get here without a 'done' event, finalize with what we have
            if (streamingContent) {
                const result = {
                    answer: streamingContent,
                    sources: streamingSources,
                    confidence: streamingConfidence || 'medium'
                };
                const queryId = 'stream-' + Date.now();
                finalizeStreamingMessage(streamingMsgId, result, queryId);
                chatHistory.push({ type: 'assistant', result, queryId });
                saveChatHistory();
            }

            return true;

        } catch (error) {
            // Remove streaming message on error
            if (streamingMsgId) {
                removeMessage(streamingMsgId);
                streamingMsgId = null;
            }
            throw error;
        }
    }

    async function sendQuestion(event) {
        event.preventDefault();

        const input = document.getElementById('question-input');
        const question = input.value.trim();

        if (!question || isLoading) return;

        input.value = '';
        isLoading = true;
        updateSendButton();

        const welcome = document.getElementById('welcome');
        if (welcome) welcome.remove();

        const onboarding = document.getElementById('onboarding-banner');
        if (onboarding) onboarding.classList.add('hidden');

        addMessage(question, 'user');
        chatHistory.push({ type: 'user', content: question });
        saveChatHistory();

        // Try streaming first
        try {
            await sendQuestionStreaming(question);
            isLoading = false;
            updateSendButton();
            await updateOnboarding();
            return;
        } catch (streamError) {
            console.warn('Streaming failed, falling back to polling:', streamError);
            // Show error if it's a real error (not just unsupported)
            if (streamError.message && !streamError.message.includes('fetch')) {
                addMessage('Error: ' + streamError.message, 'error');
                chatHistory.push({ type: 'error', content: 'Error: ' + streamError.message });
                saveChatHistory();
                isLoading = false;
                updateSendButton();
                return;
            }
        }

        // Fallback to polling-based query
        currentLoadingId = addMessage('Thinking', 'assistant', true);

        try {
            const response = await fetch('/api/v1/query', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question })
            });

            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.detail || 'Query failed');
            }

            currentQueryId = result.query_id;

            // Update loading message if queued
            if (result.status === 'queued') {
                updateLoadingMessage(result);
            }

            startQueryPolling();

        } catch (error) {
            if (currentLoadingId) {
                removeMessage(currentLoadingId);
                currentLoadingId = null;
            }
            addMessage('Error: ' + error.message, 'error');
            chatHistory.push({ type: 'error', content: 'Error: ' + error.message });
            saveChatHistory();
            isLoading = false;
            updateSendButton();
        }
    }

    // ==================== Messages ====================

    function addMessage(content, type, isLoading = false) {
        const container = document.getElementById('chat-messages');
        const id = 'msg-' + (messageCounter++);

        const div = document.createElement('div');
        div.id = id;
        div.className = `message message-${type}${isLoading ? ' message-loading' : ''}`;

        const loadingClass = isLoading ? ' loading-dots' : '';
        div.innerHTML = `
            <div class="message-bubble">
                <div class="message-content${loadingClass}">${escapeHtml(content)}</div>
            </div>
        `;

        container.appendChild(div);
        container.scrollTop = container.scrollHeight;

        return id;
    }

    function addAnswerMessage(result, queryId) {
        const container = document.getElementById('chat-messages');
        const msgId = 'msg-' + (messageCounter++);

        const div = document.createElement('div');
        div.id = msgId;
        div.className = 'message message-assistant';

        let sourcesHtml = '';
        if (result.sources && result.sources.length > 0) {
            const uniqueSources = [...new Set(result.sources.map(s => s.filename))];
            sourcesHtml = `
                <div class="message-sources">
                    <span class="source-label">Sources</span>
                    ${uniqueSources.map(f => `<span class="source-pill">${escapeHtml(f)}</span>`).join('')}
                </div>
            `;
        }

        // Check if this is a "no results" response
        const isNoResults = result.confidence === 'none';
        let noResultsHint = '';
        if (isNoResults && IS_ADMIN) {
            noResultsHint = `
                <div class="no-results-hint">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    Try checking if your documents are indexed in <a href="/admin">Admin</a>
                </div>
            `;
        } else if (isNoResults) {
            noResultsHint = `
                <div class="no-results-hint">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    No relevant information found in the indexed documents.
                </div>
            `;
        }

        const safeAnswer = escapeHtml(result.answer);
        const safeQuestion = chatHistory.filter(m => m.type === 'user').pop()?.content || '';

        div.innerHTML = `
            <div class="message-bubble">
                <div class="message-content">${safeAnswer}</div>
                ${sourcesHtml}
                ${noResultsHint}
                <div class="message-footer">
                    <span class="confidence confidence-${result.confidence}">
                        <span class="confidence-dot"></span>
                        ${result.confidence}
                    </span>
                    <div class="message-actions">
                        <button class="action-btn" onclick="copyAnswer(this, '${msgId}')" title="Copy answer">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                        <button class="action-btn feedback-btn" onclick="submitFeedback('${queryId || ''}', 'up', this)" title="Helpful" data-rating="">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                            </svg>
                        </button>
                        <button class="action-btn feedback-btn" onclick="submitFeedback('${queryId || ''}', 'down', this)" title="Not helpful" data-rating="">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        `;

        // Store answer text for copy
        div.dataset.answer = result.answer;
        div.dataset.question = safeQuestion;

        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

    function removeMessage(id) {
        const el = document.getElementById(id);
        if (el) el.remove();
    }

    // ==================== Actions ====================

    async function copyAnswer(btn, msgId) {
        const msgEl = document.getElementById(msgId);
        if (!msgEl) return;

        const answer = msgEl.dataset.answer;
        if (!answer) return;

        try {
            await navigator.clipboard.writeText(answer);
            btn.classList.add('action-btn-success');
            setTimeout(() => btn.classList.remove('action-btn-success'), 1500);
        } catch (error) {
            console.error('Failed to copy:', error);
            showToast('Failed to copy', 'error');
        }
    }

    async function submitFeedback(queryId, rating, btn) {
        const msgEl = btn.closest('.message');
        if (!msgEl) return;

        const question = msgEl.dataset.question || '';
        const answer = msgEl.dataset.answer || '';

        // Find sibling feedback buttons and update their state
        const footer = btn.closest('.message-actions');
        const feedbackBtns = footer.querySelectorAll('.feedback-btn');

        feedbackBtns.forEach(b => {
            b.classList.remove('action-btn-active');
            b.dataset.rating = '';
        });

        btn.classList.add('action-btn-active');
        btn.dataset.rating = rating;

        try {
            await fetch('/api/v1/feedback', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query_id: queryId,
                    question: question,
                    answer: answer,
                    rating: rating
                })
            });
        } catch (error) {
            console.error('Failed to submit feedback:', error);
        }
    }

    // ==================== Utilities ====================

    function updateSendButton() {
        const sendBtn = document.getElementById('send-btn');
        const stopBtn = document.getElementById('stop-btn');

        if (isLoading) {
            sendBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
        } else {
            sendBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
        }
    }

    async function cancelQuery() {
        const stopBtn = document.getElementById('stop-btn');
        stopBtn.disabled = true;
        stopBtn.innerHTML = '<span class="spinner"></span>';

        try {
            const response = await fetch('/api/v1/query/cancel', { method: 'POST' });
            const result = await response.json();

            if (result.cancelled) {
                showToast('Query cancelled', 'info');
            }
        } catch (error) {
            console.error('Failed to cancel query:', error);
        }

        // Reset UI state regardless of cancel result
        stopQueryPolling();
        if (currentLoadingId) {
            removeMessage(currentLoadingId);
            currentLoadingId = null;
        }
        addMessage('Query cancelled', 'error');
        chatHistory.push({ type: 'error', content: 'Query cancelled' });
        saveChatHistory();

        isLoading = false;
        stopBtn.disabled = false;
        stopBtn.textContent = 'Stop';
        updateSendButton();

        // Clear server-side query status
        await fetch('/api/v1/query/status', { method: 'DELETE' });
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        container.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('hiding');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    document.getElementById('onboarding-refresh').addEventListener('click', () => {
        refreshIndexFromBanner();
    });

    document.getElementById('question-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            document.getElementById('chat-form').dispatchEvent(new Event('submit'));
        }
    });
</script>
{% endblock %}
