{% extends "base.html" %}

{% block title %}PIKA - Admin{% endblock %}

{% block content %}
<!-- Header -->
<header class="header">
    <div class="header-left">
        <a href="/" class="logo">PIKA</a>
        <span class="header-divider">/</span>
        <span class="header-title">Admin</span>
    </div>
    <a href="/" class="header-link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
        Back to Chat
    </a>
</header>

<!-- Admin Layout -->
<div class="admin-layout">
    <div class="admin-grid">
        <!-- Models Section -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Models</h2>
            </div>
            <div class="card-body">
                <!-- Current Model -->
                <div class="model-current" id="current-model">
                    <span class="model-current-name" id="current-model-name">Loading...</span>
                    <span class="badge badge-success">
                        <span class="badge-dot"></span>
                        Active
                    </span>
                </div>

                <!-- Switch Model -->
                <div class="form-group">
                    <label class="form-label">Switch Model</label>
                    <div class="form-row">
                        <div class="form-group">
                            <select id="model-select" class="form-select">
                                <option value="">Loading models...</option>
                            </select>
                        </div>
                        <button class="btn btn-primary" id="switch-model-btn" onclick="switchModel()">
                            Switch
                        </button>
                    </div>
                </div>

                <!-- Pull New Model -->
                <div class="form-group" style="margin-top: 20px;">
                    <label class="form-label">Pull New Model</label>
                    <div class="form-row">
                        <div class="form-group">
                            <input
                                type="text"
                                id="model-name"
                                class="form-input"
                                placeholder="e.g., llama3.1:8b"
                            >
                        </div>
                        <button class="btn btn-secondary" id="pull-model-btn" onclick="pullModel()">
                            Pull
                        </button>
                    </div>
                    <p class="form-hint">
                        Browse models at <a href="https://ollama.com/library" target="_blank">ollama.com/library</a>
                    </p>
                </div>

                <!-- Pull Progress -->
                <div class="progress-container" id="pull-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <p class="progress-text" id="progress-text">Starting download...</p>
                </div>
            </div>
        </div>

        <!-- Documents Section -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Documents</h2>
                <button class="btn btn-primary" id="refresh-index-btn" onclick="refreshIndex()">
                    Refresh Index
                </button>
            </div>
            <div class="card-body">
                <!-- Upload Zone -->
                <div class="upload-zone" id="upload-zone">
                    <input type="file" id="file-input" multiple accept=".pdf,.docx,.txt,.md" hidden>
                    <svg class="upload-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    <p class="upload-text">Drop files here or click to browse</p>
                    <p class="upload-hint">PDF, DOCX, TXT, MD supported</p>
                </div>

                <!-- Document List -->
                <div class="document-list">
                    <table class="document-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Size</th>
                                <th>Chunks</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="document-tbody">
                            <tr>
                                <td colspan="4" class="empty-state">No documents uploaded</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Stats -->
                <div class="stats-row">
                    <div class="stat-item">
                        <span class="stat-value" id="doc-count">0</span>
                        <span class="stat-label">documents</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="chunk-count">0</span>
                        <span class="stat-label">chunks indexed</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toast-container"></div>
{% endblock %}

{% block scripts %}
<script>
    let pullPollingInterval = null;

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        loadModels();
        loadDocuments();
        loadStats();
        setupUpload();
        checkActivePull();
    });

    // ==================== Models ====================

    async function loadModels() {
        try {
            const response = await fetch('/api/v1/models');
            const models = await response.json();
            const select = document.getElementById('model-select');
            const currentName = document.getElementById('current-model-name');

            // Find current model
            const current = models.find(m => m.is_current);
            if (current) {
                currentName.textContent = `${current.name} (${current.size})`;
            }

            // Populate select
            select.innerHTML = models.map(m => `
                <option value="${m.name}" ${m.is_current ? 'selected' : ''}>
                    ${m.name} (${m.size})
                </option>
            `).join('');

            if (models.length === 0) {
                select.innerHTML = '<option value="">No models available</option>';
                currentName.textContent = 'No model selected';
            }
        } catch (error) {
            console.error('Failed to load models:', error);
            showToast('Failed to load models', 'error');
        }
    }

    async function switchModel() {
        const select = document.getElementById('model-select');
        const model = select.value;
        if (!model) return;

        const btn = document.getElementById('switch-model-btn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span>';

        try {
            const response = await fetch('/api/v1/models/current', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model })
            });

            if (!response.ok) throw new Error('Failed to switch model');

            await loadModels();
            showToast(`Switched to ${model}`, 'success');
        } catch (error) {
            showToast('Failed to switch model', 'error');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Switch';
        }
    }

    async function checkActivePull() {
        try {
            const response = await fetch('/api/v1/models/pull/status');
            const status = await response.json();

            if (status.active) {
                // There's an active pull - show progress and start polling
                showPullProgress(status);
                startPullPolling();
            }
        } catch (error) {
            console.error('Failed to check pull status:', error);
        }
    }

    function showPullProgress(status) {
        const btn = document.getElementById('pull-model-btn');
        const progress = document.getElementById('pull-progress');
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');

        btn.disabled = true;
        progress.classList.add('visible');

        if (status.error) {
            progressText.textContent = `Error: ${status.error}`;
            progressFill.style.width = '0%';
        } else if (status.total && status.completed) {
            progressFill.style.width = status.percent + '%';
            progressText.textContent = `Downloading ${status.model}: ${status.percent}%`;
        } else if (status.status) {
            progressText.textContent = `${status.model}: ${status.status}`;
            if (status.status === 'success') {
                progressFill.style.width = '100%';
            }
        }
    }

    function startPullPolling() {
        if (pullPollingInterval) return; // Already polling

        let lastModel = null;

        pullPollingInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/v1/models/pull/status');
                const status = await response.json();

                if (status.active) {
                    lastModel = status.model;
                }

                if (!status.active) {
                    // Pull completed or failed
                    stopPullPolling();
                    const btn = document.getElementById('pull-model-btn');
                    const progress = document.getElementById('pull-progress');

                    btn.disabled = false;
                    await loadModels();

                    if (lastModel) {
                        showToast(`Model ${lastModel} pulled successfully`, 'success');
                    }

                    setTimeout(() => {
                        progress.classList.remove('visible');
                    }, 2000);
                } else {
                    showPullProgress(status);
                }
            } catch (error) {
                console.error('Failed to poll pull status:', error);
            }
        }, 1000);
    }

    function stopPullPolling() {
        if (pullPollingInterval) {
            clearInterval(pullPollingInterval);
            pullPollingInterval = null;
        }
    }

    async function pullModel() {
        const input = document.getElementById('model-name');
        const modelName = input.value.trim();
        if (!modelName) return;

        // Check if model is already downloaded
        const select = document.getElementById('model-select');
        const existingModels = Array.from(select.options).map(opt => opt.value);

        // Check for exact match or base name match (e.g., "llama3.1:8b" matches "llama3.1:8b")
        const modelExists = existingModels.some(existing => {
            // Exact match
            if (existing === modelName) return true;
            // Match without tag (e.g., "llama3.1" matches "llama3.1:latest")
            const baseName = modelName.split(':')[0];
            const existingBase = existing.split(':')[0];
            return baseName === existingBase && !modelName.includes(':');
        });

        if (modelExists) {
            showToast(`Model "${modelName}" is already downloaded`, 'info');
            return;
        }

        const btn = document.getElementById('pull-model-btn');
        const progress = document.getElementById('pull-progress');
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');

        btn.disabled = true;
        progress.classList.add('visible');
        progressFill.style.width = '0%';
        progressText.textContent = 'Starting download...';

        try {
            const response = await fetch('/api/v1/models/pull', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model: modelName })
            });

            const result = await response.json();

            if (!result.started) {
                showToast(result.message, 'error');
                btn.disabled = false;
                progress.classList.remove('visible');
                return;
            }

            input.value = '';
            // Start polling for progress
            startPullPolling();

        } catch (error) {
            showToast(`Failed to pull model: ${error.message}`, 'error');
            btn.disabled = false;
            progress.classList.remove('visible');
        }
    }

    // ==================== Documents ====================

    async function loadDocuments() {
        try {
            const [docsResponse, indexedResponse] = await Promise.all([
                fetch('/documents'),
                fetch('/api/v1/documents')
            ]);

            const documents = await docsResponse.json();
            const indexed = await indexedResponse.json();

            const indexedMap = {};
            indexed.forEach(d => indexedMap[d.filename] = d.chunk_count);

            const tbody = document.getElementById('document-tbody');

            if (documents.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="4" class="empty-state">No documents uploaded</td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = documents.map(doc => `
                <tr>
                    <td class="doc-name" title="${doc.filename}">${doc.filename}</td>
                    <td class="doc-meta">${formatSize(doc.size_bytes)}</td>
                    <td class="doc-meta">${indexedMap[doc.filename] || 'â€”'}</td>
                    <td class="doc-actions">
                        <button class="btn btn-icon btn-danger" onclick="deleteDocument('${doc.filename}')" title="Delete">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </td>
                </tr>
            `).join('');
        } catch (error) {
            console.error('Failed to load documents:', error);
        }
    }

    async function loadStats() {
        try {
            const response = await fetch('/api/v1/index/stats');
            const stats = await response.json();
            document.getElementById('doc-count').textContent = stats.total_documents;
            document.getElementById('chunk-count').textContent = stats.total_chunks;
        } catch (error) {
            console.error('Failed to load stats:', error);
        }
    }

    async function refreshIndex() {
        const btn = document.getElementById('refresh-index-btn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span> Indexing...';

        try {
            const response = await fetch('/api/v1/index', { method: 'POST' });
            const result = await response.json();
            await Promise.all([loadStats(), loadDocuments()]);
            showToast(`Indexed ${result.total_documents} documents (${result.total_chunks} chunks)`, 'success');
        } catch (error) {
            showToast('Failed to refresh index', 'error');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Refresh Index';
        }
    }

    function setupUpload() {
        const uploadZone = document.getElementById('upload-zone');
        const fileInput = document.getElementById('file-input');

        uploadZone.addEventListener('click', () => fileInput.click());

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', () => {
            handleFiles(fileInput.files);
            fileInput.value = '';
        });
    }

    async function handleFiles(files) {
        for (const file of files) {
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Upload failed');
                }

                showToast(`Uploaded: ${file.name}`, 'success');
            } catch (error) {
                showToast(`Failed to upload ${file.name}`, 'error');
            }
        }
        await loadDocuments();
    }

    async function deleteDocument(filename) {
        if (!confirm(`Delete "${filename}"?`)) return;

        try {
            const response = await fetch(`/documents/${encodeURIComponent(filename)}`, {
                method: 'DELETE'
            });

            if (!response.ok) throw new Error('Delete failed');

            showToast(`Deleted: ${filename}`, 'success');
            await loadDocuments();
        } catch (error) {
            showToast('Failed to delete file', 'error');
        }
    }

    // ==================== Utilities ====================

    function formatSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        container.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('hiding');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }
</script>
{% endblock %}
